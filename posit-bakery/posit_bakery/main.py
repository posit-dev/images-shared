import json
import os
import warnings
from pathlib import Path
from pprint import pformat
from typing import Annotated, List

import jinja2
from rich import print, print_json
import typer

from posit_bakery import bake_tools
from posit_bakery.dgoss import DGossManager
from posit_bakery.templating.render import create_new_image_directories, NewImageTypes, render_new_image_template_files, \
    create_new_image_version_directory, render_new_image_version_template_files, regenerate_build_matrix

app = typer.Typer()


def auto_path():
    context = Path(os.getcwd())
    return context


@app.command()
def new(
        image_name: Annotated[str, typer.Argument(
            help="The image name to create a skeleton for."
        )],
        context: Annotated[Path, typer.Option(
            help="The root path to use. Defaults to the current working directory where invoked."
        )] = auto_path(),
        image_base: Annotated[str, typer.Option(
            help="The base to use for the new image."
        )] = "posit/base",
        image_type: Annotated[str, typer.Option(
            help="The type of image to create."
        )] = NewImageTypes.product,
):
    """Creates a quickstart skeleton for a new image."""
    image_path = create_new_image_directories(context, image_name)

    render_new_image_template_files(image_name, image_type, image_base, image_path)

    print(f"[green bold]Successfully generated {image_name}[/green bold] ✅")


@app.command()
def render(
        image_name: Annotated[str, typer.Argument(
            help="The image directory to render. This should be the path above the template directory."
        )],
        image_version: Annotated[str, typer.Argument(
            help="The new version to render the templates to."
        )],
        context: Annotated[Path, typer.Option(
            help="The root path to use. Defaults to the current working directory where invoked."
        )] = auto_path(),
        value: Annotated[List[str], typer.Option(
            help="A 'key=value' pair to pass to the templates. Accepts multiple pairs."
        )] = None,
        skip_render_minimal: Annotated[bool, typer.Option(
            help="Skip rendering the minimal version of the Containerfile."
        )] = False,
        skip_mark_latest: Annotated[bool, typer.Option(
            help="Skip marking the latest version of the image."
        )] = False,
):
    """Renders templates for an image to a versioned subdirectory of the image directory.

    This tool expects an image directory to use the following structure as generated by `bakery new`:
    .
    └── image_path/
        └── template/
            ├── optional_subdirectories/
            │   └── *.jinja2
            ├── *.jinja2
            └── Containerfile*.jinja2
    """
    image_versioned_path = create_new_image_version_directory(context, image_name, image_version)

    # Parse the key=value pairs into a dictionary
    value_map = dict()
    if value is not None:
        for v in value:
            sp = v.split("=")
            if len(sp) != 2:
                print(f"[bright_red bold]ERROR:[/bold] Expected key=value pair, got [bold]'{v}'")
                raise typer.Exit(code=1)
            value_map[sp[0]] = sp[1]
    if "rel_path" not in value_map:
        value_map["rel_path"] = image_versioned_path.relative_to(context)

    render_new_image_version_template_files(context, image_name, image_version, value_map, skip_render_minimal)

    regenerate_build_matrix(context, image_name, image_version, skip_render_minimal)

    print(f"[green bold]Successfully rendered {image_name}/{image_version}[/green bold] ✅")


@app.command()
def plan(
        context: Annotated[Path, typer.Option(
            help="The root path to use. Defaults to the current working directory where invoked."
        )] = auto_path(),
        image_name: Annotated[str, typer.Option(
            help="The image name to isolate plan rendering to."
        )] = None,
        target: Annotated[List[str], typer.Option(
            help="The targets to filter the rendered plan by. Multiple can be provided."
        )] = None,
        bake_file: Annotated[List[Path], typer.Option(
            help="The bake file(s) to use. Multiple can be provided."
        )] = None,
        no_override: Annotated[bool, typer.Option(
            help="Skip loading docker-bake.override.hcl files for auto-discovery."
        )] = False,
):
    """
    Generates a plan in JSON based off of provided or auto-discovered bake files.

    If no options are provided, the command will auto-discover all bake files in the current
    directory and generate a plan for all targets. If target names overlap, this could result in an error.

    If only an image name is provided, the command will auto-discover that image's bake file and will also load the
    root bake file and any override bake files if they exist.

    If only a bake file is provided, the command will generate a plan for that bake file only.
    """
    b = bake_tools.BakeManager(context, image_name, bake_file, no_override)
    plan = b.plan(target)
    print_json(json.dumps(plan))


@app.command()
def build(
        context: Annotated[Path, typer.Option(
            help="The root path to use. Defaults to the current working directory where invoked."
        )] = auto_path(),
        image_name: Annotated[str, typer.Option(
            help="The image name to isolate plan rendering to."
        )] = None,
        target: Annotated[List[str], typer.Option(
            help="The targets to filter the rendered plan by. Multiple can be provided."
        )] = None,
        bake_file: Annotated[List[Path], typer.Option(
            help="The bake file(s) to use. Multiple can be provided."
        )] = None,
        no_override: Annotated[bool, typer.Option(
            help="Skip loading docker-bake.override.hcl files for auto-discovery."
        )] = False,
        load: Annotated[bool, typer.Option(
            help="Load the image to Docker after building."
        )] = False,
        push: Annotated[bool, typer.Option(
            help="Push the image to the registry after building."
        )] = False,
        option: Annotated[List[str], typer.Option(
            help="Additional build options to pass to docker buildx. Multiple can be provided."
        )] = None,
):
    b = bake_tools.BakeManager(context, image_name, bake_file, no_override)
    exit_code = b.build(target, load, push, option)
    if exit_code != 0:
        print(f"[bright_red]Build failed with exit code {exit_code}[/bright_red]")
        raise typer.Exit(code=exit_code)
    else:
        print(f"[green]Build succeeded[/green]")


@app.command()
def dgoss(
        context: Annotated[Path, typer.Option(
            help="The root path to use. Defaults to the current working directory where invoked."
        )] = auto_path(),
        image_name: Annotated[str, typer.Option(
            help="The image name to isolate goss testing to."
        )] = None,
        image_version: Annotated[str, typer.Option(
            help="The image version to isolate goss testing to."
        )] = None,
        target: Annotated[List[str], typer.Option(
            help="The targets to filter the initial plan render by. Multiple can be provided."
        )] = None,
        bake_file: Annotated[List[Path], typer.Option(
            help="The bake file(s) to use. Multiple can be provided."
        )] = None,
        skip: Annotated[List[str], typer.Option(
            help="A regex filter for targets to skip. Multiple can be provided."
        )] = None,
        option: Annotated[List[str], typer.Option(
            help="Additional runtime options to pass to dgoss. Multiple can be provided."
        )] = None,
):
    b = bake_tools.BakeManager(context, image_name, bake_file)
    plan = b.plan(target)
    d = DGossManager(context, plan, image_version, skip, option)
    d.exec()
