import json
import os
from pathlib import Path
from typing import Annotated, List

from rich import print, print_json
import typer

from posit_bakery.models.project import Project
from posit_bakery.error import BakeryGossError, BakeryBuildError

app = typer.Typer()


def auto_path() -> Path:
    context = Path(os.getcwd())
    return context


@app.command()
def new(
    image_name: Annotated[str, typer.Argument(help="The image name to create a skeleton for.")],
    context: Annotated[
        Path, typer.Option(help="The root path to use. Defaults to the current working directory where invoked.")
    ] = auto_path(),
    image_base: Annotated[str, typer.Option(help="The base to use for the new image.")] = "docker.io/library/ubuntu:22.04",
) -> None:
    """Creates a quickstart skeleton for a new image."""
    project = Project.from_context(context)
    project.new_image(image_name, image_base)

    print(f"[green bold]Successfully generated {image_name}[/green bold] ✅")


@app.command()
def render(
    image_name: Annotated[
        str, typer.Argument(help="The image directory to render. This should be the path above the template directory.")
    ],
    image_version: Annotated[str, typer.Argument(help="The new version to render the templates to.")],
    context: Annotated[
        Path, typer.Option(help="The root path to use. Defaults to the current working directory where invoked.")
    ] = auto_path(),
    value: Annotated[
        List[str], typer.Option(help="A 'key=value' pair to pass to the templates. Accepts multiple pairs.")
    ] = None,
    skip_render_minimal: Annotated[
        bool, typer.Option(help="Skip rendering the minimal version of the Containerfile.")
    ] = False,
    skip_mark_latest: Annotated[bool, typer.Option(help="Skip marking the latest version of the image.")] = False,
) -> None:
    """Renders templates for an image to a versioned subdirectory of the image directory.

    This tool expects an image directory to use the following structure as generated by `bakery new`:
    .
    └── image_path/
        └── template/
            ├── optional_subdirectories/
            │   └── *.jinja2
            ├── *.jinja2
            └── Containerfile*.jinja2
    """
    project = Project.from_context(context)

    # Parse the key=value pairs into a dictionary
    value_map = dict()
    if value is not None:
        for v in value:
            sp = v.split("=")
            if len(sp) != 2:
                print(f"[bright_red bold]ERROR:[/bold] Expected key=value pair, got [bold]'{v}'")
                raise typer.Exit(code=1)
            value_map[sp[0]] = sp[1]

    project.new_image_version(image_name, image_version, value_map, not skip_mark_latest)

    print(f"[green bold]Successfully rendered {image_name}/{image_version}[/green bold] ✅")


@app.command()
def plan(
    context: Annotated[
        Path, typer.Argument(help="The root path to use. Defaults to the current working directory where invoked.")
    ] = auto_path(),
    image_name: Annotated[str, typer.Option(help="The image name to isolate plan rendering to.")] = None,
    image_version: Annotated[
        str, typer.Option(help="The image version to isolate plan rendering to. Must be used with --image-name.")
    ] = None,
    skip_override: Annotated[
        bool, typer.Option(help="Skip loading config.override.toml file for auto-discovery.")
    ] = False,
    output_file: Annotated[
        Path, typer.Option(help="The file to write the rendered plan to. Defaults to bake-plan.json.")
    ] = Path(auto_path(), "bake-plan.json"),
) -> None:
    """
    Generates a plan in JSON based off of provided or auto-discovered bake files.

    If no options are provided, the command will auto-discover all bake files in the current
    directory and generate a plan for all targets. If target names overlap, this could result in an error.

    If only an image name is provided, the command will auto-discover that image's bake file and will also load the
    root bake file and any override bake files if they exist.

    If only a bake file is provided, the command will generate a plan for that bake file only.
    """
    project = Project.from_context(context, skip_override)
    bake_plan = project.render_bake_plan(image_name, image_version)
    print_json(json.dumps(bake_plan), indent=2)
    with open(output_file, "w") as f:
        f.write(json.dumps(bake_plan, indent=2))


@app.command()
def build(
    context: Annotated[
        Path, typer.Option(help="The root path to use. Defaults to the current working directory where invoked.")
    ] = auto_path(),
    image_name: Annotated[str, typer.Option(help="The image name to isolate plan rendering to.")] = None,
    image_version: Annotated[
        str, typer.Option(help="The image version to isolate plan rendering to.")
    ] = None,
    image_type: Annotated[
        str, typer.Option(help="The image type to isolate plan rendering to.")
    ] = None,
    skip_override: Annotated[
        bool, typer.Option(help="Skip loading docker-bake.override.hcl files for auto-discovery.")
    ] = False,
    load: Annotated[bool, typer.Option(help="Load the image to Docker after building.")] = False,
    push: Annotated[bool, typer.Option(help="Push the image to the registry after building.")] = False,
    option: Annotated[
        List[str], typer.Option(help="Additional build options to pass to docker buildx. Multiple can be provided.")
    ] = None,
) -> None:
    project = Project.from_context(context, skip_override)
    try:
        project.build(load, push, image_name, image_version, image_type, option)
    except BakeryBuildError as e:
        print(f"[bright_red bold]ERROR:[/bold] Build failed with exit code {e.exit_code}")


@app.command()
def dgoss(
    context: Annotated[
        Path, typer.Option(help="The root path to use. Defaults to the current working directory where invoked.")
    ] = auto_path(),
    image_name: Annotated[str, typer.Option(help="The image name to isolate goss testing to.")] = None,
    image_version: Annotated[str, typer.Option(help="The image version to isolate goss testing to.")] = None,
    skip_override: Annotated[
        bool, typer.Option(help="Skip loading config.override.toml file for auto-discovery.")
    ] = False,
    option: Annotated[
        List[str], typer.Option(help="Additional runtime options to pass to dgoss. Multiple can be provided.")
    ] = None,
) -> None:
    project = Project.from_context(context, skip_override)
    try:
        project.dgoss(image_name, image_version, option)
    except BakeryGossError as e:
        print(f"[bright_red bold]ERROR:[/bold] dgoss tests failed with exit code {e.exit_code}")
