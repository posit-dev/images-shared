import logging
import textwrap
from pathlib import Path
from typing import Annotated, List

import typer

from posit_bakery.error import BakeryConfigError, BakeryFileError, BakeryConfigNotFoundError, \
    BakeryContextDirectoryNotFoundError
from posit_bakery.models import Project
from posit_bakery.util import auto_path


app = typer.Typer(no_args_is_help=True)

DEFAULT_BASE_IMAGE: str = "docker.io/library/ubuntu:22.04"
log = logging.getLogger(__name__)


@app.command(
    short_help="Initialize a new Bakery project",
    help=textwrap.dedent(
        """Creates a new project in the context path
    
        This tool will create a new directory in the context path with the following structure:
        
        .
        
        └── project_name/
        
            └── config.toml
        """
    )
)
def project(
    context: Annotated[
        Path, typer.Option(help="The root path to use. Defaults to the current working directory where invoked.")
    ] = auto_path(),
) -> None:
    """Creates a new project in the context path

    This tool will create a new directory in the context path with the following structure:
    .
    └── project_name/
        └── config.toml
    """
    try:
        p = Project.load(context)
    except BakeryFileError:
        p = Project.create(context)
    except BakeryConfigError as e:
        log.exception(e)
        log.error(f"The project already exists, but produced an error when loaded.")
        raise typer.Exit(code=1)

    log.info(f"✅ Successfully initialized Bakery project in '{project.context}'")


@app.command(
    short_help="Create a skeleton for a new image",
    help=textwrap.dedent(
        """Creates a quickstart skeleton for a new image with the given name in the context path.
    
        This tool will create a new directory in the context path with the following structure:
        
        .
        
        └── image_name/
        
            ├── manifest.toml
            
            └── template/
            
                ├── deps/
                
                │   └── packages.txt.jinja2
                
                ├── test/
                
                │   └── goss.yaml.jinja2
                
                └── Containerfile.jinja2
        """
    )
)
def image(
    image_name: Annotated[str, typer.Argument(help="The image name to create a skeleton for.")],
    context: Annotated[
        Path, typer.Option(help="The root path to use. Defaults to the current working directory where invoked.")
    ] = auto_path(),
    base_image: Annotated[str, typer.Option(help="The base to use for the new image.")] = DEFAULT_BASE_IMAGE,
) -> None:
    """Creates a quickstart skeleton for a new image in the context path

    This tool will create a new directory in the context path with the following structure:
    .
    └── image_name/
        ├── manifest.toml
        └── template/
            ├── deps/
            │   └── packages.txt.jinja2
            ├── test/
            │   └── goss.yaml.jinja2
            └── Containerfile.jinja2
    """

    try:
        p = Project.load(context)
    except (BakeryContextDirectoryNotFoundError, BakeryConfigNotFoundError):
        confirm = typer.prompt(f"No project was found in '{context}'. Would you like to create a new project?")
        p = Project.create(context)
    except BakeryConfigError as e:
        log.exception(e)
        log.error(f"An error occurred while loading the project!")
        raise typer.Exit(code=1)

    try:
        p.create_image(image_name, base_image)
    except BakeryConfigError as e:
        log.error(f"{e}")
        raise typer.Exit(code=1)

    log.info(f"✅ Successfully created image '{image_name}'")


@app.command(
    short_help="Render templates for an image version",
    help=textwrap.dedent(
        """Renders templates for an image to a versioned subdirectory of the image directory.
    
        This tool expects an image directory to use the following structure as generated by `bakery new`:
        
        .
        
        └── image_path/
        
            └── template/
            
                ├── optional_subdirectories/
                
                │   └── *.jinja2
                
                ├── *.jinja2
                
                └── Containerfile*.jinja2
        """
    )
)
def version(
    image_name: Annotated[
        str, typer.Argument(help="The image directory to render. This should be the path above the template directory.")
    ],
    image_version: Annotated[str, typer.Argument(help="The new version to render the templates to.")],
    context: Annotated[
        Path, typer.Option(help="The root path to use. Defaults to the current working directory where invoked.")
    ] = auto_path(),
    value: Annotated[
        List[str], typer.Option(help="A 'key=value' pair to pass to the templates. Accepts multiple pairs.")
    ] = None,
    skip_render_minimal: Annotated[
        bool, typer.Option(help="Skip rendering the minimal version of the Containerfile.")
    ] = False,
    skip_mark_latest: Annotated[bool, typer.Option(help="Skip marking the latest version of the image.")] = False,
) -> None:
    """Renders templates for an image to a versioned subdirectory of the image directory.

    This tool expects an image directory to use the following structure as generated by `bakery new`:
    .
    └── image_path/
        └── template/
            ├── optional_subdirectories/
            │   └── *.jinja2
            ├── *.jinja2
            └── Containerfile*.jinja2
    """
    p = Project.load(context)

    # TODO: Determine whether we still want to support the value map via the CLI or in a file
    # Parse the key=value pairs into a dictionary
    value_map = dict()
    if value is not None:
        for v in value:
            sp = v.split("=")
            if len(sp) != 2:
                log.error(f"❌ Expected key=value pair, got [bold]'{v}'")
                raise typer.Exit(code=1)
            value_map[sp[0]] = sp[1]

    p.create_image_version(
        image_name=image_name,
        image_version=image_version,
        mark_latest=(not skip_mark_latest),
    )

    log.info(f"✅ Successfully created version '{image_name}/{image_version}'")
