import logging
import textwrap
from pathlib import Path
from typing import Annotated, List

import typer

from posit_bakery import error
from posit_bakery.cli.common import _wrap_project_load
from posit_bakery.log import stderr_console
from posit_bakery.models import Project
from posit_bakery.util import auto_path


app = typer.Typer(no_args_is_help=True)

DEFAULT_BASE_IMAGE: str = "docker.io/library/ubuntu:22.04"
log = logging.getLogger(__name__)


@app.command()
def project(
    context: Annotated[
        Path, typer.Option(help="The root path to use. Defaults to the current working directory where invoked.")
    ] = auto_path(),
) -> None:
    """Creates a new project in the context path

    This tool will create a new directory in the context path with the following structure:

    \b
    .
    └── project_name/
        └── config.toml.
    """
    # TODO: The logic here can be improved. We can probably implement a Project.exists() method to check if a project
    #       exists rather than check exceptions.
    try:
        Project.load(context)
        stderr_console.print(f"[green3]✅ Project already exists in '{project.context}'")
    except error.BakeryFileError as e:
        log.info(f"No project found, creating a new project in '{context}'")
        try:
            Project.create(context)
            stderr_console.print(f"[green3]✅ Project initialized in '{project.context}'")
        except error.BakeryError:
            stderr_console.print_exception(max_frames=5)
            stderr_console.print(f"[bright_red]❌ Failed to initialize a new project in '{context}")
            raise typer.Exit(code=1)
    except (error.BakeryModelValidationError, error.BakeryModelValidationErrorGroup) as e:
        stderr_console.print(e)
        stderr_console.print(f"[bright_red]❌ The project already exists, but failed to load from '{context}'")
        raise typer.Exit(code=1)
    except error.BakeryError:
        stderr_console.print_exception(max_frames=5)
        stderr_console.print(f"[bright_red]❌ The project already exists, but failed to load from '{context}'")
        raise typer.Exit(code=1)
    except Exception:
        stderr_console.print_exception(max_frames=20)
        stderr_console.print(f"[bright_red]❌ Failed to load project from '{context}'")
        raise typer.Exit(code=1)


@app.command()
def image(
    image_name: Annotated[str, typer.Argument(help="The image name to create a skeleton for.")],
    context: Annotated[
        Path, typer.Option(help="The root path to use. Defaults to the current working directory where invoked.")
    ] = auto_path(),
    base_image: Annotated[str, typer.Option(help="The base to use for the new image.")] = DEFAULT_BASE_IMAGE,
) -> None:
    """Creates a quickstart skeleton for a new image in the context path

    This tool will create a new directory in the context path with the following structure:

    \b
    .
    └── image_name/
        ├── manifest.toml
        └── template/
            ├── deps/
            │   └── packages.txt.jinja2
            ├── test/
            │   └── goss.yaml.jinja2
            └── Containerfile.jinja2
    """
    p = _wrap_project_load(context)

    try:
        p.create_image(image_name, base_image)
    except error.BakeryError:
        stderr_console.print_exception(max_frames=5, show_locals=False)
        stderr_console.print(f"[bright_red]❌ Failed to create image '{image_name}'")
        raise typer.Exit(code=1)
    except Exception:
        stderr_console.print_exception(max_frames=20)
        stderr_console.print(f"[bright_red]❌ Failed to create image '{image_name}'")
        raise typer.Exit(code=1)

    stderr_console.print(f"[green3]✅ Successfully created image '{image_name}'")


@app.command()
def version(
    image_name: Annotated[
        str, typer.Argument(help="The image directory to render. This should be the path above the template directory.")
    ],
    image_version: Annotated[str, typer.Argument(help="The new version to render the templates to.")],
    context: Annotated[
        Path, typer.Option(help="The root path to use. Defaults to the current working directory where invoked.")
    ] = auto_path(),
    value: Annotated[
        List[str], typer.Option(help="A 'key=value' pair to pass to the templates. Accepts multiple pairs.")
    ] = None,
    skip_render_minimal: Annotated[
        bool, typer.Option(help="Skip rendering the minimal version of the Containerfile.")
    ] = False,
    skip_mark_latest: Annotated[bool, typer.Option(help="Skip marking the latest version of the image.")] = False,
) -> None:
    """Renders templates for an image to a versioned subdirectory of the image directory.

    This tool expects an image directory to use the following structure as generated by `bakery new`:

    \b
    .
    └── image_path/
        ├── manifest.toml
        └── template/
            ├── optional_subdirectories/
            │   └── *.jinja2
            ├── *.jinja2
            └── Containerfile*.jinja2
    """
    p = _wrap_project_load(context)

    # Parse the key=value pairs into a dictionary
    value_map = dict()
    if value is not None:
        for v in value:
            sp = v.split("=")
            if len(sp) != 2:
                stderr_console.print(f"[bright_red]❌ Expected key=value pair, got [bold]'{v}'")
                raise typer.Exit(code=1)
            value_map[sp[0]] = sp[1]

    try:
        p.create_image_version(
            image_name=image_name,
            image_version=image_version,
            mark_latest=(not skip_mark_latest),
        )
    except error.BakeryConfigError:
        stderr_console.print_exception(max_frames=5, show_locals=False)
        stderr_console.print(f"[bright_red]❌ Failed to create version '{image_name}/{image_version}'")
        raise typer.Exit(code=1)

    stderr_console.print(f"[green3]✅ Successfully created version '{image_name}/{image_version}'")
